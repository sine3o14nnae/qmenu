#!/bin/sh

dmenu() {

command dmenu -f -nb "$theme_0" -nf "$theme_1" -sb "$qube_label" -sf "$theme_0" "$@"
}

fmenu_dom0() (

chosefrom=0

while [ -n "$chosefrom" ]; do

	chosefrom=$(printf "New qube\nGlobal preferences\nLogs\nProperty Manager" |\
		dmenu -l 4 -i -p "dom0:" | cut -f1 -d\ )

	case $chosefrom in

		New)

			fqvm_create;;

		Global)

			fqubes_prefs;;

		Logs)

			fq_logs;;

		Property)

			fq_pm;;

		*)
	esac
done
)

fmenu_domu() (

# Change label colors according to user input.
qube_label=$(echo "$@" | tr ' ' '\n' |\
	grep "\--$(qvm-prefs "$qube" label)" | cut -d= -f2)

if [ -z "$qube_label" ]; then qube_label=$theme_1; fi

chosefrom=0

while [ -n "$chosefrom" ]; do

	chosefrom=$(printf "Applications\nAudio input devices\nBlock devices\nBoot\nBootfrom\nClone\nCommand\nDisk\nFirewall\nKeyboard\nKill\nLogs\nPause\nPCI devices\nPreferences\nReboot\nRemove\nServices\nShutdown\nTags\nUnpause\nUSB devices" |\
		dmenu -l 22 -i -p "$qube:" | cut -f1 -d\ )

	case $chosefrom in

		Applications)

			fqvm_appmenus;;

		Audio)

			fqvm_device;;

		Block)

			fqvm_device;;

		Boot)

			qvm-start --skip-if-running "$qube"&;;

		Bootfrom)

			qubes-vm-boot-from-device "$qube";;

		Clone)

			fqvm_clone;;

		Command)

			fqvm_run;;

		Disk)

			fqvm_volume;;

		Firewall)

			fqvm_firewall;;

		Keyboard)

			fq_keyboard;;

		Kill)

			answer=$(printf "No\nYes" | dmenu -i -p "Kill $qube?")

			if [ "$answer" = "Yes" ]; then qvm-kill "$qube"& fi;;

		Logs)

			fq_logs;;

		Pause)

			answer=$(printf "No\nYes" | dmenu -i -p "Pause $qube?")

			if [ "$answer" = "Yes" ]; then qvm-pause "$qube"& fi;;

		PCI)

			fqvm_pci;;

		Preferences)

			fqvm_prefs;;

		Reboot)

			answer=$(printf "No\nYes" | dmenu -i -p "Reboot $qube?")

			if [ "$answer" = "Yes" ]; then

				if qvm-check -q --running "$qube"; then

					$(qvm-shutdown --wait "$qube" && qvm-start "$qube")&
				fi
			fi;;

		Remove)

			fqvm_remove;;

		Services)

			fqvm_service;;

		Shutdown)

			answer=$(printf "No\nYes" | dmenu -i -p "Shutdown $qube?")

			if [ "$answer" = "Yes" ]; then qvm-shutdown "$qube"& fi;;

		Tags)

			fqvm_tags;;

		Unpause)

			qvm-unpause "$qube"&;;

		USB)

			fqvm_device;;

		*)
	esac
done
)

fq_keyboard() (

# 'qmenu-vm' does not get informed about the available layouts by the vm itself
# so it is possible that the selected layout is missing inside the vm.
# Getting the info from the vm itself, however, would have security
# implications so we will not switch to use that method.
if LAYOUT=$(ls /usr/share/X11/xkb/symbols | dmenu -l 50 -p "$qube:"); then

	if [ -d /usr/share/X11/xkb/symbols/"$LAYOUT" ]; then

		LAYOUT="$LAYOUT/"$(ls /usr/share/X11/xkb/symbols/"$LAYOUT" |\
			dmenu -l 50 -p "$qube:")
	fi

	if ! qvm-run "$qube" "setxkbmap $LAYOUT"; then

		notify-send -u normal "Error: Could not set keyboard layout to '$LAYOUT' in $qube! Please check the available layouts inside the qube itself."
	fi&
fi
)

fq_logs() (

if [ "$qube" = "dom0" ]; then

	logs="/var/log/xen/console/hypervisor.log"
else

	logs="/var/log/xen/console/guest-$qube.log\n/var/log/qubes/guid.$qube.log\n/var/log/qubes/qrexec.$qube.log"
fi

entry=0

while [ -n "$entry" ]; do

	if entry=$(printf "$logs" | dmenu -i -l 3 -p "$qube:"); then

		if log=$(dmenu -l 20 -p "$qube:" < "$entry"); then

			echo "$log" > /var/run/qubes/qubes-clipboard.bin

			printf "dom0" > /var/run/qubes/qubes-clipboard.bin.source
		fi
	fi
done
)

fq_pm() (

qubes=$(qvm-ls --no-spinner --all --exclude=dom0 -O name,label,template,netvm,default_dispvm,kernel |\
	dmenu -l 50 | cut -f1 -d\ )

if [ -n "$qubes" ]; then

	property=$(printf "Default_DispVM\nKernel\nLabel\nTemplate\nNetVM" |\
		dmenu -i -l 5 -p "Select the property you wish to change:" |\
		awk '{print tolower($0)}')

	if [ -n "$property" ]; then

		case $property in

			default_dispvm)

				get_list disptemp

				value=$(printf "(Default)\n(None)$LIST_DISPTEMP" |\
					dmenu -l 50 -p "Select default dispvm:")

				if [ "$value" = "(None)" ]; then

					value="None"

				elif [ "$value" = "(Default)" ]; then

					value="--default"
				fi;;

			kernel)

				value=$(echo "--default" |\
					dmenu -p "Enter kernel:");;

			label)

				value=$(printf "Purple\nBlue\nGray\nGreen\nYellow\nOrange\nRed\nBlack" |\
					dmenu -i -l 8 -p "Select label:" |\
					awk '{print tolower($0)}');;

			template)

				get_list template

				value=$(printf "(Default)\n$list" |\
					dmenu -l 50 -p "Select template:")

				if [ "$value" = "(Default)" ]; then

					value="--default"
				fi;;

			netvm)

				get_list netvm

				value=$(printf "(Default)\n(None)\n$list" |\
					dmenu -l 50 -p "Select netvm:")

				if [ "$value" = "(None)" ]; then

					value="None"

				elif [ "$value" = "(Default)" ]; then

					value="--default"
				fi;;

			*)
		esac

		if [ -n "$value" ]; then

			answer=$(printf "No\nYes" | dmenu -i\
				-p "Do you want to change the $property of all selected qubes to $value?")

			if [ "$answer" = "Yes" ]; then

				for qube in $qubes; do

					# Label and template should not be changed while a qube is running
					if [ "$property" = "label" ] || [ "$property" = "template" ]\
						&& qvm-check -q --running "$qube"; then

						echo "Proceed..." |\
							dmenu -p "Error: Unable to change $property of $qube because it is not shut down." > /dev/null 2>&1
					else

						if ! qvm-prefs "$qube" "$property" "$value"; then

							echo "Proceed..." |\
								dmenu -p "Error: Could not set $property of $qube to '$value'!"\
								> /dev/null 2>&1
						fi
					fi
				done
			fi
		fi
	fi
fi
)

fqubes_prefs() (

property=0

while [ -n "$property" ]; do

	property=$(qubes-prefs |\
		dmenu -l 16 -p "Global preferences:" | cut -f1 -d\ )

	case $property in

		check_updates_vm)

			value=$(printf "False\nTrue" |\
				dmenu -i -p "Should the system periodically check for domU updates?");;

		clockvm)

				get_list netvm

			value=$(printf "(None)\n$list" |\
				dmenu -l 50 -p "Select ClockVM:");;

		default_dispvm)

			get_list disptemp

			value=$(printf "(None)$LIST_DISPTEMP" |\
				dmenu -l 50 -p "Select default dispvm:");;

		default_kernel)

			if value=$(: | dmenu -p "Enter default kernel:"); then

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Set default kernel to $value?")

				if [ "$answer" != "Yes" ]; then

					unset value
				fi
			fi;;

		default_netvm)

				get_list netvm

			value=$(printf "(None)\n$list" |\
				dmenu -l 50 -p "Select default netvm:");;

		default_pool)

			value=$(qvm-pool --list | sed '1d' |\
				dmenu -i -l 30 -p "Select default storage pool:" | cut -f1 -d\ );;

		default_pool_kernel)

			value=$(qvm-pool --list | sed '1d' |\
				dmenu -i -l 30 -p "Select default storage pool for kernel volumes:"\
				| cut -f1 -d\ );;

		default_pool_private)

			value=$(qvm-pool --list | sed '1d' |\
				dmenu -i -l 30 -p "Select default storage pool for private volumes:"\
				| cut -f1 -d\ );;

		default_pool_root)

			value=$(qvm-pool --list | sed '1d' |\
				dmenu -i -l 30 -p "Select default storage pool for root volumes:"\
				| cut -f1 -d\ );;

		default_pool_volatile)

			value=$(qvm-pool --list | sed '1d' |\
				dmenu -i -l 30 -p "Select default storage pool for volatile volumes:"\
				| cut -f1 -d\ );;

		default_qrexec_timeout)

			value=$(qubes-prefs default_qrexec_timeout | dmenu\
				-p "Enter the time in seconds, after which qrexec connection attempts are deemed a failure:");;

		default_shutdown_timeout)

			value=$(qubes-prefs default_shutdown_timeout | dmenu\
				-p "Enter the default time in seconds for qube shutdowns to complete:");;

		default_template)

			get_list template

			value=$(printf "(None)\n$list" |\
				dmenu -l 50 -p "Select default template:");;

		management_dispvm)

			get_list mgmt_disptemp

			value=$(printf "(None)\n$list" |\
				dmenu -l 50 -p "Select management dispvm:");;

		stats_interval)

			value=$(: |\
				dmenu -p "Enter interval in seconds for qube stats reporting:");;

		updatevm)

			get_list netvm

			value=$(printf "(None)\n$list" |\
				dmenu -l 50 -p "Select UpdateVM:")

			if [ -n "$value" ] && [ "$value" != "(None)" ]; then

				if ! qvm-check -q --running "$value"; then

					echo "Go back..." |\
						dmenu -p "$value needs to be running!" > /dev/null 2>&1

					unset value
				fi
			fi;;

		*)
	esac

	if [ -n "$value" ]; then

		if [ "$value" = "(None)" ]; then value=''; fi

		if ! qubes-prefs "$property" "$value"; then

			echo "Go back..." |\
				dmenu -p "Error: Could not set $property to '$value'!"\
				> /dev/null 2>&1
		fi

		unset value
	fi
done
)

fqvm_appmenus() (

option=0

while [ -n "$option" ]; do

	option=$(printf "Available\nSelected" | dmenu -i -l 2 -p "$qube:")

	if [ "$option" = "Available" ]; then

		applications=0

		while [ -n "$applications" ]; do

			# Only show applications that arent already selected for $qube via 'grep -v'.
			applications=$(qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
				grep -v "$(qvm-appmenus --get-whitelist --i-understand-format-is-unstable "$qube")" |\
				dmenu -l 50 -p "$qube:" | cut -f1 -d\ )

			if [ -n "$applications" ]; then

				# Check validity of input to prevent whitelisted-appmenus.list
 				# from being filled with garbage.
				if qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
					cut -f1 -d\  | grep -q "^$applications$"; then

					printf "\n$applications" >> "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list

					applications_modified=1
				fi
			fi
		done

	elif [ "$option" = "Selected" ]; then

		applications=0

		while [ -n "$applications" ]; do

			# Show complete application and .desktop names via 'grep'.
			applications=$(qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
				grep "$(qvm-appmenus --get-whitelist --i-understand-format-is-unstable "$qube")" |\
				dmenu -l 50 -p "$qube:"  | cut -f1 -d\ )

			if [ -n "$applications" ]; then

				for application in $applications; do

					# Look up linenumber above $application in
					# /whitelisted-appmenus.list to delete if whitespace.
					whitespace=$(grep -n1 "^$application$" <\
						"$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list |\
						sed '1q;d' | cut -d- -f1)

					sed -i "${whitespace}{/^$/d;}" "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list
					sed -i "/$application/d" "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list

					applications_modified=1
				done
			fi
		done
	fi

	# Only update qvm-appmenus down here, *after* the user
	# has quit the application selection.
	if [ -n "$applications_modified" ]; then

		qvm-appmenus -q --update "$qube"

		unset applications_modified
	fi
done
)

fqvm_clone() (

if clone_name=$(: | dmenu -p "Enter the name for the clone of $qube:"); then

	option=0

	while [ -n "$option" ]; do

		option=$(printf "Create the clone\nAdvanced options" |\
			dmenu -i -l 2 -p "$qube:" | cut -f1 -d\ )

		if [ "$option" = "Advanced" ]; then

			option_adv=0

			while [ -n "$option_adv" ]; do

				option_adv=$(printf "Class\nPool" |\
					dmenu -i -l 2 -p "$clone_name($qube):")

				if [ "$option_adv" = "Class" ]; then

					if class=$(printf "AppVM\nDispVM\nStandaloneVM\nTemplateVM" |\
						dmenu -i -l 4 -p "Choose a class for $clone_name:"); then

					class="-C $class"
					fi

				elif [ "$option_adv" = "Pool" ]; then

					if pool=$(qvm-pool --list | sed '1d' | dmenu -i -l 10\
						-p "Select a pool for $clone_name:" | cut -f1 -d\ ); then

					pool="-P $pool"
					fi
				fi
			done

		elif [ "$option" = "Create" ]; then

			unset option

			qvm-clone $class $pool "$qube" "$clone_name"&
		fi
	done
fi
)

fqvm_create() (

if name=$(: | dmenu -p "Enter the name for the new qube:"); then

	label=$(printf "Red\nOrange\nYellow\nGreen\nGray\nBlue\nPurple\nBlack" |\
		dmenu -i -l 8 -p "Select label for $name:" | awk '{print tolower($0)}')

	if [ -n "$label" ]; then

		QUBEARGS="-l $label"

		if class=$(printf "AppVM\nDispVM\nStandaloneVM\nTemplateVM" |\
			dmenu -i -l 4 -p "Choose a class for $name:"); then

			QUBEARGS="$QUBEARGS -C $class"
		fi

		get_list template

		template=$(printf "(Default)\n(None)\n$list" |\
			dmenu -l 50 -p "Select template for $name:")

		if [ "$template" != "(Default)" ] && [ "$template" != "(None)" ]; then

			QUBEARGS="$QUBEARGS -t $template"
		fi

		get_list netvm

		netvm=$(printf "(Default)\n(None)\n$list" |\
			dmenu -l 50 -p "Select netvm for $name:")

		if [ "$netvm" != "(Default)" ]; then

			if [ "$netvm" = "(None)" ]; then unset netvm; fi

			QUBEARGS="$QUBEARGS --prop netvm=$netvm"
		fi

		provides_network=$(printf "No\nYes" |\
			dmenu -i -p "Should $name provide networking for other qubes?")

		if [ "$provides_network" = "Yes" ]; then

			QUBEARGS="$QUBEARGS --prop provides_network=true"
		fi

		option=0

		while [ -n "$option" ]; do

			option=$(printf "Create the new qube\nAdvanced options" |\
				dmenu -i -l 2 -p "dom0:" | cut -f1 -d\ )

			if [ "$option" = "Advanced" ]; then

				option_adv=$(printf "Pool" | dmenu -l 1 -p "$name:")

				if [ "$option_adv" = "Pool" ]; then

					pool=$(qvm-pool --list | sed '1d' |\
						dmenu -i -l 10 -p "Select a pool for $name:" | cut -f1 -d\ )

					if [ -n "$pool" ]; then pool="-P $pool"; fi
				fi

			elif [ "$option" = "Create" ]; then

				qvm-create $QUBEARGS $pool "$name"&

				unset option
			fi
		done
	fi
fi
)

fqvm_device() (

if ! qvm-check -q --running "$qube"; then

	echo "Go back..." |\
		dmenu -p "$qube needs to be running, in order to attach devices to it."\
		> /dev/null 2>&1
else

	case $chosefrom in

		Audio) device_type="device mic";;

		Block) device_type="block";;

		USB) device_type="usb"
	esac

	devices_list=$(qvm-$device_type)

	device=0

	while [ -n "$device" ]; do

		device=$(echo "$devices_list" | dmenu -l 16 -p "$qube:")

		if [ -n "$device" ] && [ "$(echo "$device" | wc -l)" -eq 1 ]; then

			device_id=$(echo "$device" | cut -f1 -d\ )

			if [ "$device_type" = "block" ]; then

				device_name=$(echo "$device" | awk '{print $2,$3}')
				holds_qube=$(echo "$device" | awk '{print $4}')
			else

				device_name=$(echo "$device" | awk '{print $2}')
				holds_qube=$(echo "$device" | awk '{print $3}')
			fi

			if [ -z "$holds_qube" ]; then

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Attach '$device_name' to $qube?")

				if [ "$answer" = "Yes" ]; then

					unset device

					if ! qvm-$device_type attach -q "$qube" "$device_id"; then

						echo "Go back..." | dmenu -p "Error: Could not attach device!"\
							> /dev/null 2>&1
					fi
				fi

			elif [ "$holds_qube" = "$qube" ]; then

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Detach '$device_name' from $qube?")

				if [ "$answer" = "Yes" ]; then

					unset device

					if ! qvm-$device_type detach -q "$holds_qube" "$device_id"; then

						echo "Go back..." | dmenu -p "Error: Could not detach device!"\
							> /dev/null 2>&1
					fi
				fi
			else

				answer=$(printf "No\nYes" | dmenu -i\
					-p "Detach '$device_name' from $holds_qube and attach it to $qube?")

				if [ "$answer" = "Yes" ]; then

					unset device

					if qvm-$device_type detach -q "$holds_qube" "$device_id"; then

						if ! qvm-$device_type attach -q "$qube" "$device_id"; then

							echo "Go back..." | dmenu\
								-p "Error: Could not attach device!" > /dev/null 2>&1
						fi
					fi
				fi
			fi
		fi
	done
fi
)

fqvm_firewall() (

rulenumber=0

while [ -n "$rulenumber" ]; do

	rulenumber=$(qvm-firewall $qube list |\
		dmenu -l 50 -p "$qube:" | cut -f1 -d\ )

	if [ "$(echo "$rulenumber" | wc -w)" -eq 1 ]; then

		# This will equal "NO" if the user selects the top row,
		# instead of any existing rule.
		if [ "$rulenumber" != "NO" ]; then

			option=$(printf "Add new rule above rule $rulenumber\nRemove rule $rulenumber" |\
				dmenu -i -l 2 -p "$qube:" | cut -f1 -d\ )
		else

			option="Add"
		fi

		if [ "$option" = "Remove" ]; then

			answer=$(printf "No\nYes" |\
				dmenu -i -p "Remove rule $rulenumber?")

			if [ "$answer" = "Yes" ]; then

				qvm-firewall "$qube" del --rule-no "$rulenumber"
			fi

		elif [ "$option" = "Add" ]; then

			if [ -n "$RULEARGS" ]; then unset RULEARGS; fi

			action=$(printf "Accept\nDrop" |\
				dmenu -i -l 2 -p "Select action for the new firewall rule:" |\
				awk '{print tolower($0)}')

			if [ -n "$action" ]; then

				RULEARGS="$action"

				if specialtarget=$(: | dmenu -p "ACTION=$RULEARGS <specialtarget>"); then

					RULEARGS="$RULEARGS SPECIALTARGET=$specialtarget"
				fi

				if dsthost=$(: | dmenu -p "ACTION=$RULEARGS <dsthost>"); then

					RULEARGS="$RULEARGS DSTHOST=$dsthost"
				fi

				if proto=$(: | dmenu -p "ACTION=$RULEARGS <proto>"); then

					RULEARGS="$RULEARGS PROTO=$proto"
				fi

				if [ "$proto" = "tcp" ] || [ "$proto" = "udp" ]; then

					if dstports=$(: | dmenu -p "ACTION=$RULEARGS <dstports>"); then

						RULEARGS="$RULEARGS DSTPORTS=$dstports"
					fi

				elif [ "$proto" = "icmp" ]; then

					if icmptype=$(: | dmenu -p "ACTION=$RULEARGS <icmptype>"); then

						RULEARGS="$RULEARGS ICMPTYPE=$icmptype"
					fi
				fi

				if expire=$(: | dmenu -p "ACTION=$RULEARGS <expire>"); then

					RULEARGS="EXPIRE=$expire"
				fi

				if comment=$(: | dmenu -p "ACTION=$RULEARGS <comment>"); then

					RULEARGS="$RULEARGS COMMENT=$comment"
				fi

				answer=$(printf "No\nYes" | dmenu -i\
					-p "Add the following rule to $qube? {{ ACTION=$RULEARGS }}")

				if [ "$answer" = "Yes" ]; then

					if [ -n "$beforerule" ]; then unset beforerule; fi

					if [ "$rulenumber" != "NO" ]; then

						beforerule=$(echo --before "$rulenumber")
					fi

					RULEARGS=$(echo "$RULEARGS" | awk '{print tolower($0)}')

					if ! qvm-firewall "$qube" add $beforerule $RULEARGS; then

						echo "Go back..." | dmenu\
							-p "Error: Failed to add firewall rule! See 'qvm-firewall --help' for more information."\
							> /dev/null 2>&1
					fi
				fi
			fi
		fi
	fi
done
)

fqvm_pci() (

if qvm-check -q --running "$qube"; then

	echo "Go back..." | dmenu\
		-p "$qube needs to be powered off, in order to attach or detach PCI devices."\
		> /dev/null 2>&1
else

	list_pci=$(qvm-pci)

	if ! qvm-prefs "$qube" maxmem | grep -q ^0; then

		answer=$(printf "Continue anyways\nDisable dynamic memory balancing" |\
			dmenu -l 2 -i -p "Dynamic memory balancing is enabled in $qube, some devices might not work!"\
			| cut -f1 -d\ )

		if [ "$answer" = "Disable" ]; then

			qvm-prefs "$qube" maxmem 0
		fi
	fi

	if qvm-prefs "$qube" virt_mode | grep -q pvh; then

		answer=$(printf "Continue anyways\nSelect another virtualisation mode" |\
			dmenu -l 2 -i -p "$qube is using PVH for its virtualisation mode, which does not support PCI passthrough!"\
			| cut -f1 -d\ )

		if [ "$answer" = "Select" ]; then

			if virtmode=$(printf "HVM\nPV" |\
				dmenu -l 2 -i -p "Select virtualisation mode for $qube:"); then

				qvm-prefs "$qube" virt_mode "$virtmode"
			fi
		fi
	fi

	device=0

	while [ -n "$device" ]; do

		device=$(echo "$list_pci" | dmenu -l 30 -p "$qube:")

		if [ -n "$device" ] && [ "$(echo "$device" | wc -l)" -eq 1 ]; then

			device_src=$(echo "$device" | cut -f1 -d\ | sed 's/:.*//')
			device_bdf=$(echo "$device" | cut -f1 -d\ | sed 's/.*://')

			if echo "$device" |\
				grep -q " $qube$\\| $qube (no-strict-reset=True)$\\| $qube (permissive=True)$"; then

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Detach \"$device_bdf\" from $qube?")

				if [ "$answer" = "Yes" ]; then

					if ! qvm-pci detach "$qube" "$device_src":"$device_bdf"; then

						echo "Go back..." | dmenu\
							-p "Error: Failed to detach \"$device_bdf\" from $qube!"\
							> /dev/null 2>&1
					fi

					list_pci=$(qvm-pci)
				fi
			else

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Attach \"$device_bdf\" to $qube?")

				if [ "$answer" = "Yes" ]; then

					# Check if there is more than one function
					# that belongs to the same device.
					bdf_count=$(echo "$list_pci" | cut -f1 -d\  |\
						grep -c $(echo "$device_bdf" | sed 's/\..*//'))

					if [ "$bdf_count" -gt 1 ]; then

						if [ -n "$pci_option" ]; then unset pci_option; fi

							answer=$(printf "No, attach without this option\nYes" | dmenu -i\
								-p "\"$device_bdf\" is most likely to be attached with the option 'no-strict-reset' enabled. Please be aware of the security implications! Do you want to attach \"$device_bdf\" with the option 'no-strict-reset' set to true?")

						if [ "$answer" = "Yes" ]; then

							pci_option="-o no-strict-reset=True"
						fi
					fi

					if ! qvm-pci attach --persistent $pci_option "$qube" "$device_src:$device_bdf"; then

						echo "Go back..." | dmenu\
							-p "Error: Failed to attach '$device_bdf' to $qube!"\
							> /dev/null 2>&1
					fi

					list_pci=$(qvm-pci)
				fi
			fi
		fi
	done
fi
)

fqvm_prefs() (

property=0

while [ -n "$property" ]; do

	property=$(qvm-prefs "$qube" |\
		dmenu -l 45 -p "$qube:" | cut -f1 -d\ )

	if [ -n "$property" ]; then

		case $property in

			autostart)

				value=$(printf "False\nTrue" |\
					dmenu -i -p "Set autostart of $qube to:");;

			debug)

				value=$(printf "False\nTrue" |\
					dmenu -i -p "Set debug mode of $qube to:");;

			default_dispvm)

				get_list disptemp

				value=$(printf "(Default)\n(None)$LIST_DISPTEMP" |\
					dmenu -l 50 -p "Select default dispvm for $qube:")

				if [ "$value" = "(None)" ]; then

					value="None"

				elif [ "$value" = "(Default)" ]; then

					value="--default"
				fi;;

			default_user)

				value=$(echo "--default" |\
					dmenu -p "Enter the name of the default user for $qube:");;

			include_in_backups)

				value=$(printf "False\nTrue" |\
					dmenu -i -p "Include $qube in backups?");;

			kernel)

				if value=$(echo "--default" |\
					dmenu -p "Enter the kernel to be used by $qube:"); then

					answer=$(printf "No\nYes" |\
						dmenu -i -p "Set kernel of $qube to $value?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			kernelopts)

				if value=$(echo "--default" |\
					dmenu -p "Enter the kernel options for $qube:"); then

					answer=$(printf "No\nYes" | dmenu -i\
						-p "Set kernel options for $qube to \"$value\"?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			label)

				if qvm-check -q --running "$qube"; then

					echo "Go back..." | dmenu\
						-p "$qube needs to be powered off, in order to change its label."\
						> /dev/null 2>&1
				else

					value=$(printf "Purple\nBlue\nGray\nGreen\nYellow\nOrange\nRed\nBlack" |\
						dmenu -i -l 8 -p "Select label for $qube:" |\
						awk '{print tolower($0)}')
				fi;;

			mac)

				if value=$(echo "--default" |\
					dmenu -p "Enter the MAC address for $qube:"); then

					answer=$(printf "No\nYes" |\
						dmenu -i -p "Set MAC address of $qube to $value?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			maxmem)

				if value=$(echo "--default" |\
					dmenu -p "Enter the maximum amount of memory in MB to be allocated to $qube. Setting it to 0 will disable dynamic memory balancing.")

				then answer=$(printf "No\nYes" | dmenu -i\
						-p "Set maximum memory of $qube to $value MB?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			memory)

				if value=$(echo "--default" | dmenu\
					-p "Enter the amount of initial memory in MB to be allocated to $qube:")

				then answer=$(printf "No\nYes" | dmenu -i\
						-p "Set initial memory of $qube to $value MB?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			netvm)

				get_list netvm

				value=$(printf "(Default)\n(None)\n$list" |\
					dmenu -l 50 -p "Select netvm for $qube:")

				if [ "$value" = "(None)" ]; then

					value="None"

				elif [ "$value" = "(Default)" ]; then

					value="--default"
				fi;;

			provides_network)

				value=$(printf "False\nTrue" | dmenu -i\
					-p "Should $qube provide networking to other qubes?");;

			qrexec_timeout)

				if value=$(echo "--default" | dmenu\
					-p "Enter the time in seconds, after which qrexec connection attempts are deemed a failure for $qube:")

				then answer=$(printf "No\nYes" | dmenu -i\
					-p "Set qrexec timeout for $qube to $value seconds?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			shutdown_timeout)

				if value=$(echo "--default" | dmenu\
					-p "Enter the time in seconds for shutdown, after which $qube may be forcefully powered off:")

				then answer=$(printf "No\nYes" | dmenu -i\
						-p "Set shutdown timeout for $qube to $value seconds?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			template)

				if qvm-check -q --running "$qube"; then

					echo "Go back..." | dmenu\
						-p "$qube needs to be powered off, in order to change its template."\
						> /dev/null 2>&1
				else

					get_list template

					value=$(printf "(Default)\n$list" |\
						dmenu -l 50 -p "Select template for $qube:")

					if [ "$value" = "(Default)" ]; then

						value="--default"
					fi
				fi;;

			template_for_dispvms)

				value=$(printf "False\nTrue" | dmenu -i\
					-p "Should $qube be used as a template for disposable qubes?");;

			vcpus)

				if value=$(echo "--default" | dmenu\
					-p "Enter the number of CPU cores that should be made available to $qube:")

				then answer=$(printf "No\nYes" | dmenu -i\
						-p "Set number of CPU cores available to $qube to $value?")

					if [ "$answer" != "Yes" ]; then

						unset value
					fi
				fi;;

			virt_mode)

				value=$(printf "PVH\nHVM\nPV" |\
					dmenu -i -l 3 -p "Select virtualisation mode for $qube:");;

			*)
		esac

		if [ -n "$value" ]; then

			if ! qvm-prefs "$qube" "$property" "$value"; then

				echo "Go back..." |\
					dmenu -p "Error: Could not set $property to '$value'!"\
					> /dev/null 2>&1
			fi

			unset value
		fi
	fi
done
)

fqvm_remove() {

if qvm-check -q --running "$qube"; then

	echo "Go back..." |\
		dmenu -p "$qube needs to be powered off, in order to be removed."\
		> /dev/null 2>&1
else

	confirmation=$(: |\
		dmenu -p "Enter the name of the qube '$qube' in order to remove it:")

	if [ "$qube" = "$confirmation" ]; then

		confirmation_semifinal=$(printf "No\nYes" |\
			dmenu -i -p "Are you sure you want to remove '$qube' permanently?")

		if [ "$confirmation_semifinal" = "Yes" ]; then

			confirmation_final=$(printf "No\nYes" | dmenu -i\
				-p "Are you really sure you want to remove '$qube' permanently?")

			if [ "$confirmation_final" = "Yes" ]; then

				if ! qvm-remove -f "$qube"; then

					notify-send -u normal "Error: Unable to remove "$qube"!"
				fi

			fi&

			unset chosefrom
		fi
	fi
fi
}

fqvm_run() (

if user=$(printf "Default user\nRoot" | dmenu -i -l 2 -p "Run commands as:"); then

	if [ "$user" = "Root" ]; then

		as_root="-u root"
		user='#'
	else

		user='$'
	fi

	commandtr=0

	while [ -n "$commandtr" ]; do

		if commandtr=$(: | dmenu -p "($user)Run command in $qube:"); then

			qvm-run -q $as_root "$qube" "$commandtr"& fi
	done
fi
)

fqvm_service() (

services=0

while [ -n "$services" ]; do

	services=$(qvm-service "$qube" --list |\
		dmenu -l 32 -p "$qube:" | cut -f1 -d\ )

	if [ -n "$services" ]; then

		for service in $services; do

			# If the service has already been added to the list,
			# give option to unset it.
			if qvm-service "$qube" --list | grep -q "^$service "; then

				 unset="\nUnset"
			fi

			value=$(printf "Disable\nEnable$unset" |\
				dmenu -l 3 -i -p "Select value for '$service':")

			if [ "$value" = "Disable" ]; then

				if ! qvm-service "$qube" "$service" off; then

					echo "Go back..." | dmenu -p "Error: Could not deactivate '$service'!"\
						> /dev/null 2>&1
				fi

			elif [ "$value" = "Enable" ]; then

				if ! qvm-service "$qube" "$service" on; then

					echo "Go back..." | dmenu -p "Error: Could not activate '$service'!"\
						> /dev/null 2>&1
				fi

			elif [ "$value" = "Unset" ]; then

				if ! qvm-service "$qube" "$service" --unset; then

					echo "Go back..." | dmenu -p "Error: Could not unset '$service'!"\
						> /dev/null 2>&1
				fi
			fi

			if [ -n "$unset" ]; then unset unset; fi
		done
	fi
done
)

fqvm_tags() (

tags=0

while [ -n "$tags" ]; do

	tags=$(qvm-tags "$qube" list |\
		dmenu -l 15 -p "$qube:" | cut -f1 -d\ )

	if [ -n "$tags" ]; then

		for tag in $tags; do

			if qvm-tags "$qube" list | grep -q "^$tag$"; then

				answer=$(printf "No\nYes" |\
					dmenu -i -p "Remove tag '$tag' from $qube?")

				if [ "$answer" = "Yes" ]; then

					qvm-tags "$qube" del "$tag"
				fi
			else

				qvm-tags "$qube" add "$tag"
			fi
		done
	fi
done
)

fqvm_volume() (

qube_class=$(qvm-ls --raw-data -O flags "$qube" | cut -c 1)

# If $qube is template or standalone, give option to extend root storage.
if [ "$qube_class" = "t" ] ||\
	 [ "$qube_class" = "s" ] ||\
	 [ "$qube_class" = "S" ]; then

	volume=$(printf "Root\nPrivate" |\
		dmenu -l 2 -i -p "$qube:" | awk '{print tolower($0)}')
else

	volume="private"
fi

if [ -n "$volume" ]; then

	current_storage=$(( $(qvm-volume info "$qube:$volume" size) / 1048576 ))

	if mebibyte=$(echo "$current_storage" | dmenu\
		-p "Enter the maximum size of $volume storage in MiB to be allocated to $qube:"); then

		if [ "$mebibyte" -gt "$current_storage" ]; then

			byte=$(( mebibyte * 1048576 ))

			answer=$(printf "No\nYes" | dmenu -i\
				-p "Increase the maximum $volume storage size of $qube from $current_storage MiB to $mebibyte MiB?")

			if [ "$answer" = "Yes" ]; then

				qvm-volume extend "$qube:$volume" "$byte"&
			fi
		else

			echo "Go back..." | dmenu -p "Error: Can not decrease the maximum $volume storage!"\
				> /dev/null 2>&1
		fi
	fi
fi
)

get_list() {

if [ "$1" = "disptemp" ]; then

	if [ -z "$LIST_DISPTEMP" ]; then

		# [mediocre] Look up disposable templates in a very slow way...
		for n in $(qvm-ls --raw-data -O NAME,FLAGS |\
			grep '|a.....-.$' | cut -d '|' -f1); do

			if qvm-prefs "$n" template_for_dispvms | grep -q True; then

				LIST_DISPTEMP="$LIST_DISPTEMP\n$n"
			fi
		done
	fi
else

	case $1 in

		mgmt_disptemp) flags='|a.....D.$';;

		netvm) flags='|...N....$';;

		template) flags='|t.......$'

	esac

	list=$(qvm-ls --raw-data -O NAME,FLAGS | grep "$flags" | cut -d '|' -f1)
fi
}


if [ "$2" = "--light-theme" ]; then

	theme_0='#ffffff'
	theme_1='#000000'
else

	theme_0='#000000'
	theme_1='#ffffff'
fi

qube_label=$theme_1

case $1 in

	--focused)

		qube=$(xprop -id "$(xdotool getwindowfocus)" _QUBES_VMNAME | cut -d\" -f2)

		if [ "$qube" = "_QUBES_VMNAME:  not found." ]; then

			qube=dom0

			fmenu_dom0
		else

			fmenu_domu "$@"
		fi

		exit 1;;

	--qube=*)

		qube=$(echo "$1" | cut -d= -f2)

		if [ "$qube" = "dom0" ]; then

			fmenu_dom0
		else

			fmenu_domu "$@"
		fi

		exit 1;;

	--all|--halted|--paused|--running|--tags=*);;

	*)

		printf "Usage: $0 [OPTION] (--light-theme) (--{LABEL}=#{HEX TRIPLET})...\nList, manage and configure your qubes via dmenu.\n\n --all\n --focused\n --halted\n --paused\n --running\n --qube=[QUBE]\n --tags=[TAG]\n\n"

		if [ "$1" = "--help" ]; then exit 0; fi; exit 2
esac

while :; do

	# Load 'qvm-ls' into a variable so that it doesnt
	# need to reload again after every user operation.
	qube_list=$(qvm-ls --no-spinner "$1" -O name,state,label,memory,maxmem,class,template,netvm,default_dispvm,ip,priv-max,priv-curr,priv-used,root-max,root-curr,root-used,kernel |\
		sed 's/ LABEL/ 0\@ /g; s/ red/ 1\@ /g; s/ orange/ 2\@ /g; s/ yellow/ 3\@ /g; s/ green/ 4\@ /g; s/ gray/ 5\@ /g; s/ blue/ 6\@ /g; s/ purple/ 7\@ /g; s/ black/ 8\@ /g' |\
		sort -k3,3 |\
		sed 's/ 0\@ / LABEL/g; s/ 1\@ / red/g; s/ 2\@ / orange/g; s/ 3\@ / yellow/g; s/ 4\@ / green/g; s/ 5\@ / gray/g; s/ 6\@ / blue/g; s/ 7\@ / purple/g; s/ 8\@ / black/g')

	# Get out of the while loop and refresh 'qvm-ls' by loading it again
	# into $qube_list, whenever the user selects the 'qvm-ls' top row.
	while [ "$qubes" != "NAME" ]; do

		qubes=$(echo "$qube_list" | dmenu -l 50 | cut -f1 -d\ )

		if [ -z "$qubes" ]; then exit 1; fi

		for qube in $qubes; do

			if [ "$qube" = "dom0" ]; then

				fmenu_dom0

			elif [ "$qube" != "NAME" ]; then

				fmenu_domu "$@"
			fi
		done
	done

	unset qubes
done
